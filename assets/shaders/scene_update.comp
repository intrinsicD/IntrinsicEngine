#version 460
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 64) in;

struct InstanceData {
    mat4 Model;
    uint TextureID;
    uint EntityID;
    uint GeometryID;
    uint Pad1;
};

struct InstanceUpdate {
    uint SlotIndex;
    InstanceData Data;
    vec4 SphereBounds; // xyz = center, w = radius
};

layout(std430, set = 0, binding = 0) readonly buffer Updates {
    InstanceUpdate Deltas[];
} updates;

layout(std430, set = 0, binding = 1) buffer Scene {
    InstanceData Instances[];
} scene;

layout(std430, set = 0, binding = 2) buffer Bounds {
    vec4 Spheres[];
} bounds;

layout(push_constant, scalar) uniform Push {
    uint UpdateCount;
} pc;

void main()
{
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= pc.UpdateCount) return;

    InstanceUpdate u = updates.Deltas[gid];

    // Sentinel contract(GeometryID): 0xFFFFFFFF means "preserve existing GeometryID".
    // This is required because the Stage 3 multi-geometry path uses a per-frame dense GeometryID.
    // We want transform/material refresh to be able to keep routing stable.
    if (u.Data.GeometryID == 0xFFFFFFFFu)
        u.Data.GeometryID = scene.Instances[u.SlotIndex].GeometryID;

    scene.Instances[u.SlotIndex] = u.Data;

    // Sentinel contract: if radius < 0, keep the existing sphere bounds.
    // This lets CPU-side systems update transforms/materials without recomputing local bounds.
    if (u.SphereBounds.w >= 0.0)
    {
        bounds.Spheres[u.SlotIndex] = u.SphereBounds;
    }
}
